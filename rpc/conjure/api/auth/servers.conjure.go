// This file was generated by Conjure and should not be manually edited.

package auth

import (
	"context"
	"net/http"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/codecs"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-server/httpserver"
	werror "github.com/palantir/witchcraft-go-error"
	"github.com/palantir/witchcraft-go-server/v2/witchcraft/wresource"
	"github.com/palantir/witchcraft-go-server/v2/wrouter"
)

// Auth service provides functionality to log in/out of the service.
type AuthServiceV1 interface {
	/*
	   Login to the service with a username/password.
	   Returns an InvalidLoginRequest error if the request was invalid.
	*/
	Login(ctx context.Context, requestArg LoginRequestV1) (LoginResponseV1, error)
}

// RegisterRoutesAuthServiceV1 registers handlers for the AuthServiceV1 endpoints with a witchcraft wrouter.
// This should typically be called in a witchcraft server's InitFunc.
// impl provides an implementation of each endpoint, which can assume the request parameters have been parsed
// in accordance with the Conjure specification.
func RegisterRoutesAuthServiceV1(router wrouter.Router, impl AuthServiceV1) error {
	handler := authServiceV1Handler{impl: impl}
	resource := wresource.New("authservicev1", router)
	if err := resource.Post("Login", "/v1/auth/login", httpserver.NewJSONHandler(handler.HandleLogin, httpserver.StatusCodeMapper, httpserver.ErrHandler)); err != nil {
		return werror.Wrap(err, "failed to add login route")
	}
	return nil
}

type authServiceV1Handler struct {
	impl AuthServiceV1
}

func (a *authServiceV1Handler) HandleLogin(rw http.ResponseWriter, req *http.Request) error {
	var request LoginRequestV1
	if err := codecs.JSON.Decode(req.Body, &request); err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	respArg, err := a.impl.Login(req.Context(), request)
	if err != nil {
		return err
	}
	rw.Header().Add("Content-Type", codecs.JSON.ContentType())
	return codecs.JSON.Encode(rw, respArg)
}
